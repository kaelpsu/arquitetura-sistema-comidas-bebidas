Model SysADLModel ; 
package SysADL.types { 
	value type Int { } 
	value type Boolean { } 
	value type String { } 
	value type Void { } 
	value type Real { }
dimension Moeda dimension Volume enum StatusPagamento { PENDENTE , CONFIRMADO , REJEITADO } enum StatusPedido { NOVO , EM_PREPARACAO , PRONTO , COLETADO } unit BRL { dimension = Moeda } unit Mililitro { dimension = Volume } value type Preco { unit = BRL dimension = Moeda } value type Quantidade { } datatype TokenSessao { } datatype CartaoCredito { attributes : numCartao : String ; validade : String ; cvv : String ; valor : Preco ; } datatype RespostaPagamento { } datatype Pedido { } datatype Telemetria { } datatype PedidoItem { } unit Litro { dimension = Volume } enum AtivacaoMotor { LIGAR , DESLIGAR } value type Sinal { } datatype RequisicaoPagamento { } datatype AtualizacaoInterface { } enum OperacaoSaldo { DEBITAR , ADICIONAR } } Requirement SVBCRequisitos ( 0 ) { text = "O sistema deve satisfazer requisitos funcionais e nao-funcionais." 
	Requirement AutomatizarVendaDeComidasEBebidasFR ( 1 ) { text = "O sistema deve ser capaz de automatizar servicos de vendas de comidas e bebidas." 
		Requirement AutenticarEntradaFR ( 2 ) { text = "Deve ser controlada a entrada e saida de clientes com cartao RFID." 
			
		} Requirement ComprareRecarregarCreditosFR ( 3 ) { text = "Deve ser possivel comprar e recarregar creditos do cartao em quiosques." } 
		Requirement PagarProdutoFR ( 4 ) { text = "Clientes devem conseguir pagar pelos produtos com o cartao nas maquinas de venda automatica." 
			Requirement CobrarDeMaquinaFR ( 9 ) { text = "As maquinas de venda automatica devem debitar creditos com base em valores pre-estabelecidos para cada produto." } 
			Requirement CobrarDeTorneiraFR ( 10 ) { text = "As torneiras de bebidas devem calcular o valor a ser cobrado com base em quantos ml foram consumidos." }
		} Requirement PedirSobDemandaFR ( 5 ) { text = "Realizar pedido em quiosque/máquina com cartão." 
		} Requirement FecharContaFR ( 6 ) { text = "Cliente deve ser capaz de quitar o saldo pendente." } 
		Requirement GerenciarSistemaFR ( 7 ) { text = "Deve ser possivel gerenciar os diferentes componentes do sistema." 
			Requirement GerenciarCatalogoePrecosFR ( 13 ) { text = "Deve ser possivel controlar o catalogo de produtos oferecidos, assim como seus precos." } 
			Requirement MonitorarDispositivosFR ( 14 ) { text = "Deve ser possivel monitorar os dispositivos do sistema." } 
			Requirement GerenciarEstoqueFR ( 15 ) { text = "Deve ser possivel gerenciar a quantidade de cada produto no estoque." } 
			Requirement GerenciarUsuariosFR ( 16 ) { text = "Deve ser possivel gerenciar os usuarios do sistema." } 
			Requirement GerarRelatoriosFR ( 18 ) { text = "Deve ser possivel gerar relatorios para auditorias." } 
			Requirement ArmazenarDespesasFR ( 17 ) { text = "Deve ser possivel armazenar as despesas dos clientes." }
		}
	} Requirement QualidadeseRestricoesNFR ( 19 ) { text = "O sistema deve satisfazer requisitos de disponibilidade, privacidade, seguranca e escalabilidade."   
	Requirement SegurancaNFR ( 27 ) { text = "O sistema deve ter boa seguranca e garantir privacidade das operacoes e dados." Requirement RedePrivadaNFR ( 20 ) { text = "O sistema deve ter uma rede privada para a comunicacao dos processos de autenticacao e pagamento." } } Requirement DisponibilidadeNFR ( 28 ) { text = "O sistema deve possuir boa disponibilidade e tolerância a falhas." Requirement ModoOfflineNFR ( 26 ) { text = "O sistema deve possuir um modo de operacao offline para a realizacao de operações críticas na borda, para permitir vendas temporariamente quando o backend central estiver inacessível.\n" } } Requirement ConfiabilidadeNFR ( 29 ) { text = "O sistema deve ser confiavel." Requirement ConsistenciaDeDebitosNFR ( 22 ) { text = "O sistema deve ser capaz de manter a consistencia dos debitos de credito, evitando double-spend." } Requirement ConformidadePCIDSS_NFR ( 25 ) { text = "O sistema deve seguir o padrão PCI DSS (Payment Card Industry Data Security Standard), para lidar com cartoes de credito." } } }
}
Requirement RepassarPedidoParaCozinha ( 11 ) { text = "Pedidos devem aparecer na fila da cozinha." derive SVBCRequisitos.AutomatizarVendaDeComidasEBebidasFR.PedirSobDemandaFR ; } 
Requirement RetirarPedidoFR ( 12 ) { text = "Cliente deve poder retirar pedido mediante apresentação do cartao." derive SVBCRequisitos.AutomatizarVendaDeComidasEBebidasFR.PedirSobDemandaFR ; }
Requirement EmitirTokensFR ( 8 ) { text = "Devem ser emitidos tokens associados aos cartoes para seu controle no sistema." derive SVBCRequisitos.AutomatizarVendaDeComidasEBebidasFR.AutenticarEntradaFR ; }
Requirement ProtocolosIoT_NFR ( 23 ) { text = "O sistema deve utilizar protocolos IoT leves e seguros." derive SVBCRequisitos.QualidadeseRestricoesNFR.SegurancaNFR.RedePrivadaNFR ; } 
Requirement SincronizacaoComBackendNFR ( 24 ) { text = "O sistema deve permitir a sincronizacao com o backend central apos a operacao em modo offline." derive SVBCRequisitos.QualidadeseRestricoesNFR.DisponibilidadeNFR.ModoOfflineNFR ; } package SystemPorts { import SysADL.types ; port def LeitorCartaoOPT { flow out String } port def AutenticacaoIPT { flow in String } port def MotorIPT { flow in AtivacaoMotor } port def AutenticacaoOPT { flow out Boolean } port def LeitorCartaoIPT { flow in String } port def SinalIPT { flow in Sinal } port def SinalOPT { flow out Sinal } port def RequisicaoIOPT { flow inout String } port def RespostaIOPT { flow inout String } port def ClenteServidorCPT { ports : requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; } port def MotorOPT { flow out AtivacaoMotor } port def LiberadoIPT { flow in Boolean } port def AtualizaInterfaceIPT { flow in AtualizacaoInterface } port def AtualizaInterfaceOPT { flow out AtualizacaoInterface } port def AutorizacaoIPT { flow in Boolean } port def AutorizacaoOPT { flow out Boolean } port def PedidoIPT { flow in Pedido } port def PedidoOPT { flow out Pedido } port def PrecoIPT { flow in Preco } port def PrecoOPT { flow out Preco } port def BooleanIPT { flow in Boolean } port def BooleanOPT { flow in Boolean } port def OperacaoSaldoIPT { flow in OperacaoSaldo } port def OperacaoSaldoOPT { flow out OperacaoSaldo } port def CartaoCreditoIPT { flow in CartaoCredito } port def CartaoCreditoOPT { flow out CartaoCredito } } package SystemComponents { import SystemPorts ; import SysADL.types ; import SystemConnectors ;
	component def TorneiraCP { }
	component def CatracaCP { 
		ports : rede : ClenteServidorCPT ;
		configuration { components : b1 : BotaoFisicoCP { using ports : acesso1 : SinalOPT ; } LeitorCartaoCP : LeitorCartaoCP { using ports :  saida : LeitorCartaoOPT ; } bracos : MotorCP { using ports : ativacao2 : MotorIPT ; } dispensadorCartao : MotorCP { using ports : ativacao1 : MotorIPT ; } ca1 : ControladorAcessoCP { using ports : acesso2 : SinalIPT ; cartaoid : AutenticacaoIPT ; validado : AutenticacaoOPT ; controle1 : MotorOPT ; controle2 : MotorOPT ; requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; } connectors : autc1 : AutenticadorCartaoCN bindings saida = cartaoid ; aa1 : DecisaoMotorCN bindings controle1 = ativacao1 ; aa2 : DecisaoMotorCN bindings controle2 = ativacao2 ; acc1 : SinalCN bindings acesso1 = acesso2 ; delegations : requisicao to requisicao resposta to resposta }
	}
	component def MaquinaDeLanchesCP { ports : rede : ClenteServidorCPT ; configuration { components : leitor : LeitorCartaoCP { using ports : saida : LeitorCartaoOPT ; } autenticacao : ModuloAutenticacaoCP { using ports : cartaoid : AutenticacaoIPT ; requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; validado1 : AutenticacaoOPT ; } saldo : ControladorSaldo { using ports : resp : RespostaIOPT ; req : RequisicaoIOPT ; ok : BooleanOPT ; valor : PrecoIPT ; opin : OperacaoSaldoIPT ; autenticado : BooleanIPT ; } liberador : ModuloLiberacaoCP { using ports : controleMotor : MotorOPT ; liberado : LiberadoIPT ; } motor : MotorCP { using ports : ativacao : MotorIPT ; } tela : TelaCP { using ports : comando1 : SinalOPT ; } interface : InterfaceCP { using ports : comando2 : SinalIPT ; pedido1 : PedidoOPT ; } gastos : CalculadorGastosCP { using ports : pedido2 : PedidoIPT ; preco : PrecoOPT ; opout : OperacaoSaldoOPT ; } connectors : p1 : PedidoCN bindings pedido1 = pedido2 ; s1 : SinalCN bindings comando1 = comando2 ; authc : AutenticadorCartaoCN bindings saida = cartaoid ; auth : BooleanCN bindings validado1 = autenticado ; os1 : OperacaoSaldoCN bindings opout = opin ; val1 : PrecoCN bindings preco = valor ; l1 : LiberadorCN bindings ok = liberado ; dm1 : DecisaoMotorCN bindings controleMotor = ativacao ; delegations : resposta to rede requisicao to rede resp to rede req to rede } }
	component def MaquinaDePedidosCP { 
    ports : net : ClenteServidorCPT ; 
    configuration { 
        components : 
            tela : TelaCP { 
                using ports : out1 : SinalOPT ; 
            } 
            estoque : ControladorEstoqueCP { 
                using ports : reqE : RequisicaoIOPT ; 
                             respE : RespostaIOPT ; 
                             pin  : PedidoIPT ; 
                             pout : PedidoOPT ; 
            } 
            leitor : LeitorCartaoCP { 
                using ports : cardOut : LeitorCartaoOPT ; 
            } 
            auth : ModuloAutenticacaoCP { 
                using ports : cardIn : AutenticacaoIPT ; 
                             reqA   : RequisicaoIOPT ; 
                             respA  : RespostaIOPT ; 
                             validA : AutenticacaoOPT ; 
            } 
            ui : InterfaceCP { 
                using ports : in1   : SinalIPT ; 
                              
                             pOut  : PedidoOPT ; 
            } 
            pedidos : ServicoPedidosCP { 
                using ports : reqP  : RequisicaoIOPT ; 
                             respP : RespostaIOPT ; 
                             pIn   : PedidoIPT ; 
                             pago  : BooleanIPT ; 
            } 
            gastos : CalculadorGastosCP { 
                using ports : pInG  : PedidoIPT ; 
                             preco : PrecoOPT ; 
                             opOut : OperacaoSaldoOPT ; 
            } 
             
	    saldo : ControladorSaldo { using ports : respS : RespostaIOPT ; reqS : RequisicaoIOPT ; ok : BooleanOPT ; valor : PrecoIPT ; opin : OperacaoSaldoIPT ; autenticado : BooleanIPT ; } connectors : s1 : SinalCN bindings out1 = in1 ; p1 : PedidoCN bindings pOut = pin ; p2 : PedidoCN bindings pout = pInG ; os1 : OperacaoSaldoCN bindings opOut = opin ; val1 : PrecoCN bindings preco = valor ; p3 : PedidoCN bindings pout = pIn ; authc : AutenticadorCartaoCN bindings cardOut = cardIn ; b1 : BooleanCN bindings validA = autenticado ; b2 : BooleanCN bindings ok = pago ; delegations : reqA to net respA to net reqP to net respP to net reqE to net respE to net respS to net reqS to net } 
	}
	component def PontoRecargaCP { ports : rede : ClenteServidorCPT ; configuration { components : tela : TelaCP { using ports : comando1 : SinalOPT ; } pagamento : ModuloPagamentosCP { using ports : resp2 : RespostaIOPT ; req2 : RequisicaoIOPT ; cartaocred : CartaoCreditoIPT ; valor2 : PrecoIPT ; autenticado : BooleanIPT ; pago : BooleanOPT ; } saldo : ControladorSaldo { using ports : resp3 : RespostaIOPT ; req3 : RequisicaoIOPT ; valor : PrecoIPT ; opin : OperacaoSaldoIPT ; pago2 : BooleanIPT ; } autenticacao : ModuloAutenticacaoCP { using ports : cartaoid : AutenticacaoIPT ; req1 : RequisicaoIOPT ; resp1 : RespostaIOPT ; validado : AutenticacaoOPT ; } leitor : LeitorCartaoCP { using ports : saida : LeitorCartaoOPT ; } interface : InterfaceCP { using ports : comando2 : SinalIPT ; valor1 : PrecoOPT ; cartaocredout : CartaoCreditoOPT ; oper : OperacaoSaldoOPT ; } connectors : authc : AutenticadorCartaoCN bindings saida = cartaoid ; auth : BooleanCN bindings validado = autenticado ; val1 : PrecoCN bindings valor1 = valor2 ; cred : CartaoCreditoCN bindings cartaocredout = cartaocred ; s1 : SinalCN bindings comando1 = comando2 ; val2 : PrecoCN bindings valor1 = valor ; oper1 : OperacaoSaldoCN bindings oper = opin ; pagou : BooleanCN bindings pago = pago2 ; delegations : req1 to rede resp1 to rede resp3 to rede req3 to rede resp2 to rede req2 to rede } }
	component def PontoDeColetaCP { ports : rede : ClenteServidorCPT ; configuration { components : leitor : LeitorCartaoCP { using ports : saida : LeitorCartaoOPT ; } autenticacao : ModuloAutenticacaoCP { using ports : cartaoid : AutenticacaoIPT ; requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; validado : AutenticacaoOPT ; } liberacao : ModuloLiberacaoCP { using ports : controleMotor : MotorOPT ; validado2 : LiberadoIPT ; } compartimento : MotorCP { using ports : ativacao : MotorIPT ; } autorizacao : ModuloAutorizacaoCP { using ports : autenticado : AutorizacaoIPT ; autorizado : AutorizacaoOPT ; } connectors : authc : AutenticadorCartaoCN bindings saida = cartaoid ; authok : AutenticadoCN bindings validado = autenticado ; autok : AutorizadoCN bindings autorizado = validado2 ; liberaok : LiberadorCN bindings controleMotor = ativacao ; delegations : resposta to resposta requisicao to requisicao } }
	component def PainelCozinhaCP { ports : rede : ClenteServidorCPT ; configuration { components : cliente : ClienteRealTimeCP { using ports : requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; atualiza : AtualizaInterfaceOPT ; } tela : TelaCP { using ports : comando : SinalOPT ; } ui : InterfaceCP { using ports : comando2 : SinalIPT ; atualiza2 : AtualizaInterfaceIPT ; } connectors : sinal : SinalCN bindings comando = comando2 ; atualizacao : AtualizacaoInterfaceCN bindings atualiza = atualiza2 ; delegations : resposta to resposta requisicao to requisicao } }
	component def MotorCP { ports : ativacao : MotorIPT ; }
	component def LeitorCartaoCP { ports :  saida : LeitorCartaoOPT ; }
	component def TelaCP { ports : comando : SinalOPT ; }
	component def BotaoFisicoCP { ports : acesso : SinalOPT ; }
	component def InterfaceCP { ports : comando : SinalIPT ; atualiza : AtualizaInterfaceIPT ; pedido : PedidoOPT ; valor : PrecoOPT ; cartaocredout : CartaoCreditoOPT ; oper : OperacaoSaldoOPT ; }
	component def ControladorAcessoCP { ports : acesso : SinalIPT ; token : AutenticacaoIPT ; validado : AutenticacaoOPT ; controle1 : MotorOPT ; controle2 : MotorOPT ; requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; } component def ModuloAutenticacaoCP { ports : cartaoid : AutenticacaoIPT ; requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; validado : AutenticacaoOPT ; }
	component def ModuloEntradaCP { ports : acesso : SinalIPT ; controleMotor : MotorOPT ; }
	component def ModuloLiberacaoCP { ports : controleMotor : MotorOPT ; validado : LiberadoIPT ; valor : PrecoIPT ; }
	component def MaquinaDeBebidasCP { ports : rede : ClenteServidorCPT ; configuration { components :  leitor : LeitorCartaoCP { using ports : saida : LeitorCartaoOPT ; } autenticacao : ModuloAutenticacaoCP { using ports : cartaoid : AutenticacaoIPT ; req2 : RequisicaoIOPT ; resp2 : RespostaIOPT ; validado : AutenticacaoOPT ; } tela : TelaCP { using ports : comando : SinalOPT ; } interface : InterfaceCP { using ports : comando2 : SinalIPT ;  pedidout : PedidoOPT ;    } estoque : ControladorEstoqueCP { using ports : req1 : RequisicaoIOPT ; resp1 : RespostaIOPT ; pedidoin : PedidoIPT ; pedidout2 : PedidoOPT ; } gastos : CalculadorGastosCP { using ports : pedidoin2 : PedidoIPT ; preco : PrecoOPT ; opout : OperacaoSaldoOPT ; } saldo : ControladorSaldo { using ports : resp3 : RespostaIOPT ; req3 : RequisicaoIOPT ; ok : BooleanOPT ; valor : PrecoIPT ; opin : OperacaoSaldoIPT ; autenticado : BooleanIPT ; } liberador : ModuloLiberacaoCP { using ports : controleMotor : MotorOPT ; validado2 : LiberadoIPT ;  } bomba : MotorCP { using ports : ativacao : MotorIPT ; } connectors : authc : AutenticadorCartaoCN bindings saida = cartaoid ; auth : BooleanCN bindings validado = autenticado ; l1 : LiberadorCN bindings ok = validado2 ; dm1 : DecisaoMotorCN bindings controleMotor = ativacao ; oper1 : OperacaoSaldoCN bindings opout = opin ; val1 : PrecoCN bindings preco = valor ; p2 : PedidoCN bindings pedidout2 = pedidoin2 ; p1 : PedidoCN bindings pedidout = pedidoin ; s1 : SinalCN bindings comando = comando2 ; delegations : req1 to rede resp1 to rede resp3 to rede req3 to rede req2 to rede resp2 to rede } }
	component def SensorLiquidosCP { }
	component def CalculadorGastosCP { ports : pedido : PedidoIPT ; preco : PrecoOPT ; opout : OperacaoSaldoOPT ; }
	component def ModuloPagamentosCP { ports : resposta : RespostaIOPT ; requisicao : RequisicaoIOPT ; cartaocredin : CartaoCreditoIPT ; valor : PrecoIPT ; autenticado : BooleanIPT ; pago : BooleanOPT ; }
	component def ServidorCentralCP { }
	component def SistemaVendasComidasBebidas { } component def ClienteRealTimeCP { ports : requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; atualiza : AtualizaInterfaceOPT ; }
	component def ServidorRealTimeCP { }
	component def ModuloAutorizacaoCP { ports : autenticado : AutorizacaoIPT ; autorizado : AutorizacaoOPT ; }
	component def ControladorSaldo { ports : resposta : RespostaIOPT ; requisicao : RequisicaoIOPT ; ok : BooleanOPT ; valor : PrecoIPT ; opin : OperacaoSaldoIPT ; autenticado : BooleanIPT ; }
	component def ServicoPedidosCP { ports : requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; pedido : PedidoIPT ; pago : BooleanIPT ; }
	component def ControladorEstoqueCP { ports : requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; pedidoin : PedidoIPT ; pedidout : PedidoOPT ; } } package SystemConnectors { import SystemPorts ; connector def AutenticadorCartaoCN { participants : ~ fonte : LeitorCartaoOPT ; ~ destino : AutenticacaoIPT ; flows : String from fonte to destino } connector def DecisaoMotorCN { participants : ~ fonte : MotorOPT ; ~ destino : MotorIPT ; flows : AtivacaoMotor from fonte to destino } connector def SinalCN { participants : ~ fonte : SinalOPT ; ~ destino : SinalIPT ; flows : Sinal from fonte to destino } connector def RequisicaoRedeCN { participants : ~ fonte : RequisicaoIOPT ; ~ destino : RequisicaoIOPT ; flows : String from fonte to destino } connector def RespostaRedeCN { participants : ~ fonte : RespostaIOPT ; ~ destino : RespostaIOPT ; flows : String from fonte to destino } connector def AtualizacaoInterfaceCN { participants : ~ fonte : AtualizaInterfaceOPT ; ~ destino : AtualizaInterfaceIPT ; flows : AtualizacaoInterface from fonte to destino } connector def AutenticadoCN { participants : ~ fonte : AutenticacaoOPT ; ~ destino : AutorizacaoIPT ; flows : Boolean from fonte to destino } connector def LiberadorCN { participants : ~ destino : MotorOPT ; ~ fonte : LiberadoIPT ; flows : Boolean from fonte to destino } connector def AutorizadoCN { participants : ~ fonte : AutorizacaoOPT ; ~ destino : LiberadoIPT ; flows : Boolean from fonte to destino } connector def PedidoCN { participants : ~ fonte : PedidoOPT ; ~ destino : PedidoIPT ; flows : Pedido from fonte to destino } connector def PrecoCN { participants : ~ fonte : PrecoOPT ; ~ destino : PrecoIPT ; flows : Preco from fonte to destino } connector def BooleanCN { participants : ~ fonte : BooleanOPT ; ~ destino : BooleanOPT ; flows : Boolean from fonte to destino } connector def OperacaoSaldoCN { participants : ~ fonte : OperacaoSaldoOPT ; ~ destino : OperacaoSaldoIPT ; } connector def CartaoCreditoCN { participants : ~ fonte : CartaoCreditoOPT ; ~ destino : CartaoCreditoIPT ; flows : CartaoCredito from fonte to destino } }
