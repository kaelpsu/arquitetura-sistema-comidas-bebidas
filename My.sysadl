Model SysADLModel ; 
package SysADL.types { 
	value type Int { } 
	value type Boolean { } 
	value type String { } 
	value type Void { } 
	value type Real { }
dimension Moeda dimension Volume enum StatusPagamento { PENDENTE , CONFIRMADO , REJEITADO } enum StatusPedido { NOVO , EM_PREPARACAO , PRONTO , COLETADO } unit BRL { dimension = Moeda } unit Mililitro { dimension = Volume } value type Preco { unit = BRL dimension = Moeda } value type Quantidade { } datatype TokenSessao { } datatype CartaoCredito { attributes : numCartao : String ; validade : String ; cvv : String ; valor : Preco ; } datatype RespostaPagamento { } datatype Pedido { } datatype Telemetria { } datatype PedidoItem { } unit Litro { dimension = Volume } enum AtivacaoMotor { LIGAR , DESLIGAR } value type Sinal { } datatype RequisicaoPagamento { } datatype AtualizacaoInterface { } enum OperacaoSaldo { DEBITAR , ADICIONAR } } Requirement SVBCRequisitos ( 0 ) { text = "O sistema deve satisfazer requisitos funcionais e nao-funcionais." 
	Requirement AutomatizarVendaDeComidasEBebidasFR ( 1 ) { text = "O sistema deve ser capaz de automatizar servicos de vendas de comidas e bebidas." 
		Requirement AutenticarEntradaFR ( 2 ) { text = "Deve ser controlada a entrada e saida de clientes com cartao RFID." 
			
		} Requirement ComprareRecarregarCreditosFR ( 3 ) { text = "Deve ser possivel comprar e recarregar creditos do cartao em quiosques." } 
		Requirement PagarProdutoFR ( 4 ) { text = "Clientes devem conseguir pagar pelos produtos com o cartao nas maquinas de venda automatica." 
			Requirement CobrarDeMaquinaFR ( 9 ) { text = "As maquinas de venda automatica devem debitar creditos com base em valores pre-estabelecidos para cada produto." } 
			Requirement CobrarDeTorneiraFR ( 10 ) { text = "As torneiras de bebidas devem calcular o valor a ser cobrado com base em quantos ml foram consumidos." }
		} Requirement PedirSobDemandaFR ( 5 ) { text = "Realizar pedido em quiosque/máquina com cartão." 
		} Requirement FecharContaFR ( 6 ) { text = "Cliente deve ser capaz de quitar o saldo pendente." } 
		Requirement GerenciarSistemaFR ( 7 ) { text = "Deve ser possivel gerenciar os diferentes componentes do sistema." 
			Requirement GerenciarCatalogoePrecosFR ( 13 ) { text = "Deve ser possivel controlar o catalogo de produtos oferecidos, assim como seus precos." } 
			Requirement MonitorarDispositivosFR ( 14 ) { text = "Deve ser possivel monitorar os dispositivos do sistema." } 
			Requirement GerenciarEstoqueFR ( 15 ) { text = "Deve ser possivel gerenciar a quantidade de cada produto no estoque." } 
			Requirement GerenciarUsuariosFR ( 16 ) { text = "Deve ser possivel gerenciar os usuarios do sistema." } 
			Requirement GerarRelatoriosFR ( 18 ) { text = "Deve ser possivel gerar relatorios para auditorias." } 
			Requirement ArmazenarDespesasFR ( 17 ) { text = "Deve ser possivel armazenar as despesas dos clientes." }
		}
	} Requirement QualidadeseRestricoesNFR ( 19 ) { text = "O sistema deve satisfazer requisitos de disponibilidade, privacidade, seguranca e escalabilidade."   
	Requirement SegurancaNFR ( 27 ) { text = "O sistema deve ter boa seguranca e garantir privacidade das operacoes e dados." Requirement RedePrivadaNFR ( 20 ) { text = "O sistema deve ter uma rede privada para a comunicacao dos processos de autenticacao e pagamento." } } Requirement DisponibilidadeNFR ( 28 ) { text = "O sistema deve possuir boa disponibilidade e tolerância a falhas." Requirement ModoOfflineNFR ( 26 ) { text = "O sistema deve possuir um modo de operacao offline para a realizacao de operações críticas na borda, para permitir vendas temporariamente quando o backend central estiver inacessível.\n" } } Requirement ConfiabilidadeNFR ( 29 ) { text = "O sistema deve ser confiavel." Requirement ConsistenciaDeDebitosNFR ( 22 ) { text = "O sistema deve ser capaz de manter a consistencia dos debitos de credito, evitando double-spend." } Requirement ConformidadePCIDSS_NFR ( 25 ) { text = "O sistema deve seguir o padrão PCI DSS (Payment Card Industry Data Security Standard), para lidar com cartoes de credito." } } }
}
Requirement RepassarPedidoParaCozinha ( 11 ) { text = "Pedidos devem aparecer na fila da cozinha." derive SVBCRequisitos.AutomatizarVendaDeComidasEBebidasFR.PedirSobDemandaFR ; } 
Requirement RetirarPedidoFR ( 12 ) { text = "Cliente deve poder retirar pedido mediante apresentação do cartao." derive SVBCRequisitos.AutomatizarVendaDeComidasEBebidasFR.PedirSobDemandaFR ; }
Requirement EmitirTokensFR ( 8 ) { text = "Devem ser emitidos tokens associados aos cartoes para seu controle no sistema." derive SVBCRequisitos.AutomatizarVendaDeComidasEBebidasFR.AutenticarEntradaFR ; }
Requirement ProtocolosIoT_NFR ( 23 ) { text = "O sistema deve utilizar protocolos IoT leves e seguros." derive SVBCRequisitos.QualidadeseRestricoesNFR.SegurancaNFR.RedePrivadaNFR ; } 
Requirement SincronizacaoComBackendNFR ( 24 ) { text = "O sistema deve permitir a sincronizacao com o backend central apos a operacao em modo offline." derive SVBCRequisitos.QualidadeseRestricoesNFR.DisponibilidadeNFR.ModoOfflineNFR ; } package SystemPorts { import SysADL.types ; port def LeitorCartaoOPT { flow out String } port def AutenticacaoIPT { flow in String } port def MotorIPT { flow in AtivacaoMotor } port def AutenticacaoOPT { flow out Boolean } port def LeitorCartaoIPT { flow in String } port def SinalIPT { flow in Sinal } port def SinalOPT { flow out Sinal } port def RequisicaoIOPT { flow inout String } port def RespostaIOPT { flow inout String } port def ClenteServidorCPT { ports : requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; } port def MotorOPT { flow out AtivacaoMotor } port def LiberadoIPT { flow in Boolean } port def AtualizaInterfaceIPT { flow in AtualizacaoInterface } port def AtualizaInterfaceOPT { flow out AtualizacaoInterface } port def AutorizacaoIPT { flow in Boolean } port def AutorizacaoOPT { flow out Boolean } port def PedidoIPT { flow in Pedido } port def PedidoOPT { flow out Pedido } port def PrecoIPT { flow in Preco } port def PrecoOPT { flow out Preco } port def BooleanIPT { flow in Boolean } port def BooleanOPT { flow in Boolean } port def OperacaoSaldoIPT { flow in OperacaoSaldo } port def OperacaoSaldoOPT { flow out OperacaoSaldo } } package SystemComponents { import SystemPorts ; import SysADL.types ; import SystemConnectors ;
	component def TorneiraCP { }
	component def CatracaCP { 
		ports : rede : ClenteServidorCPT ;
		configuration { components : b1 : BotaoFisicoCP { using ports : acesso1 : SinalOPT ; } LeitorCartaoCP : LeitorCartaoCP { using ports :  saida : LeitorCartaoOPT ; } bracos : MotorCP { using ports : ativacao2 : MotorIPT ; } dispensadorCartao : MotorCP { using ports : ativacao1 : MotorIPT ; } ca1 : ControladorAcessoCP { using ports : acesso2 : SinalIPT ; cartaoid : AutenticacaoIPT ; validado : AutenticacaoOPT ; controle1 : MotorOPT ; controle2 : MotorOPT ; requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; } connectors : autc1 : AutenticadorCartaoCN bindings saida = cartaoid ; aa1 : DecisaoMotorCN bindings controle1 = ativacao1 ; aa2 : DecisaoMotorCN bindings controle2 = ativacao2 ; acc1 : SinalCN bindings acesso1 = acesso2 ; delegations : requisicao to requisicao resposta to resposta }
	}
	component def MaquinaDeLanchesCP { }
	component def MaquinaDePedidosCP { ports : rede : ClenteServidorCPT ; configuration { components : tela : TelaCP { using ports : comando : SinalOPT ; } ControladorEstoqueCP : ControladorEstoqueCP { using ports : requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; pedidoin : PedidoIPT ; pedidout : PedidoOPT ; } LeitorCartaoCP : LeitorCartaoCP { using ports : saida : LeitorCartaoOPT ; } ModuloAutenticacaoCP : ModuloAutenticacaoCP { using ports : cartaoid : AutenticacaoIPT ; requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; validado : AutenticacaoOPT ; } InterfaceCP : InterfaceCP { using ports : comando : SinalIPT ; atualiza : AtualizaInterfaceIPT ; pedido : PedidoOPT ; } ServicoPedidosCP : ServicoPedidosCP { using ports : requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; pedido : PedidoIPT ; pago : BooleanIPT ; } CalculadorGastosCP : CalculadorGastosCP { using ports : pedido : PedidoIPT ; preco : PrecoOPT ; operacao : OperacaoSaldoOPT ; } ControladorSaldo : ControladorSaldo { using ports : resposta : RespostaIOPT ; requisicao : RequisicaoIOPT ; ok : BooleanOPT ; newPort : OperacaoSaldoIPT ; } } }
	component def QuiosqueCP { }
	component def PontoDeColetaCP { ports : rede : ClenteServidorCPT ; configuration { components : leitor : LeitorCartaoCP { using ports : saida : LeitorCartaoOPT ; } autenticacao : ModuloAutenticacaoCP { using ports : cartaoid : AutenticacaoIPT ; requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; validado : AutenticacaoOPT ; } liberacao : ModuloLiberacaoCP { using ports : controleMotor : MotorOPT ; validado2 : LiberadoIPT ; } compartimento : MotorCP { using ports : ativacao : MotorIPT ; } autorizacao : ModuloAutorizacaoCP { using ports : autenticado : AutorizacaoIPT ; autorizado : AutorizacaoOPT ; } connectors : authc : AutenticadorCartaoCN bindings saida = cartaoid ; authok : AutenticadoCN bindings validado = autenticado ; autok : AutorizadoCN bindings autorizado = validado2 ; liberaok : LiberadorCN bindings controleMotor = ativacao ; delegations : resposta to resposta requisicao to requisicao } }
	component def PainelCozinhaCP { ports : rede : ClenteServidorCPT ; configuration { components : cliente : ClienteRealTimeCP { using ports : requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; atualiza : AtualizaInterfaceOPT ; } tela : TelaCP { using ports : comando : SinalOPT ; } ui : InterfaceCP { using ports : comando2 : SinalIPT ; atualiza2 : AtualizaInterfaceIPT ; } connectors : sinal : SinalCN bindings comando = comando2 ; atualizacao : AtualizacaoInterfaceCN bindings atualiza = atualiza2 ; delegations : resposta to resposta requisicao to requisicao } }
	component def MotorCP { ports : ativacao : MotorIPT ; }
	component def LeitorCartaoCP { ports :  saida : LeitorCartaoOPT ; }
	component def TelaCP { ports : comando : SinalOPT ; }
	component def BotaoFisicoCP { ports : acesso : SinalOPT ; }
	component def InterfaceCP { ports : comando : SinalIPT ; atualiza : AtualizaInterfaceIPT ; pedido : PedidoOPT ; }
	component def ControladorAcessoCP { ports : acesso : SinalIPT ; token : AutenticacaoIPT ; validado : AutenticacaoOPT ; controle1 : MotorOPT ; controle2 : MotorOPT ; requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; } component def ModuloAutenticacaoCP { ports : cartaoid : AutenticacaoIPT ; requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; validado : AutenticacaoOPT ; }
	component def ModuloEntradaCP { ports : acesso : SinalIPT ; controleMotor : MotorOPT ; }
	component def ModuloLiberacaoCP { ports : controleMotor : MotorOPT ; validado : LiberadoIPT ; }
	component def MaquinaDeBebidasCP { configuration { components : TelaCP : TelaCP ; LeitorCartaoCP : LeitorCartaoCP { using ports : saida : LeitorCartaoOPT ; } ModuloAutenticacaoCP : ModuloAutenticacaoCP { using ports : token : AutenticacaoIPT ; requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; validado : AutenticacaoOPT ; } } }
	component def SensorLiquidosCP { }
	component def CalculadorGastosCP { ports : pedido : PedidoIPT ; preco : PrecoOPT ; operacao : OperacaoSaldoOPT ; }
	component def ModuloPagamentosCP { ports : resposta : RespostaIOPT ; requisicao : RequisicaoIOPT ; }
	component def ServidorCentralCP { }
	component def SistemaVendasComidasBebidas { } component def ClienteRealTimeCP { ports : requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; atualiza : AtualizaInterfaceOPT ; }
	component def ServidorRealTimeCP { }
	component def ModuloAutorizacaoCP { ports : autenticado : AutorizacaoIPT ; autorizado : AutorizacaoOPT ; }
	component def ControladorSaldo { ports : resposta : RespostaIOPT ; requisicao : RequisicaoIOPT ; ok : BooleanOPT ; newPort : OperacaoSaldoIPT ; }
	component def ServicoPedidosCP { ports : requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; pedido : PedidoIPT ; pago : BooleanIPT ; }
	component def ControladorEstoqueCP { ports : requisicao : RequisicaoIOPT ; resposta : RespostaIOPT ; pedidoin : PedidoIPT ; pedidout : PedidoOPT ; } } package SystemConnectors { import SystemPorts ; connector def AutenticadorCartaoCN { participants : ~ fonte : LeitorCartaoOPT ; ~ destino : AutenticacaoIPT ; flows : String from fonte to destino } connector def DecisaoMotorCN { participants : ~ fonte : MotorOPT ; ~ destino : MotorIPT ; flows : AtivacaoMotor from fonte to destino } connector def SinalCN { participants : ~ fonte : SinalOPT ; ~ destino : SinalIPT ; flows : Sinal from fonte to destino } connector def RequisicaoRedeCN { participants : ~ fonte : RequisicaoIOPT ; ~ destino : RequisicaoIOPT ; flows : String from fonte to destino } connector def RespostaRedeCN { participants : ~ fonte : RespostaIOPT ; ~ destino : RespostaIOPT ; flows : String from fonte to destino } connector def AtualizacaoInterfaceCN { participants : ~ fonte : AtualizaInterfaceOPT ; ~ destino : AtualizaInterfaceIPT ; flows : AtualizacaoInterface from fonte to destino } connector def AutenticadoCN { participants : ~ fonte : AutenticacaoOPT ; ~ destino : AutorizacaoIPT ; flows : Boolean from fonte to destino } connector def LiberadorCN { participants : ~ destino : MotorOPT ; ~ fonte : LiberadoIPT ; flows : Boolean from fonte to destino } connector def AutorizadoCN { participants : ~ fonte : AutorizacaoOPT ; ~ destino : LiberadoIPT ; flows : Boolean from fonte to destino } connector def PedidoCN { participants : ~ fonte : PedidoOPT ; ~ destino : PedidoIPT ; flows : Pedido from fonte to destino } connector def PrecoCN { participants : ~ fonte : PrecoOPT ; ~ destino : PrecoIPT ; flows : Preco from fonte to destino } connector def BooleanCN { participants : ~ fonte : BooleanOPT ; ~ destino : BooleanOPT ; flows : Boolean from fonte to destino } connector def OperacaoSaldoCN { participants : ~ fonte : OperacaoSaldoOPT ; ~ destino : OperacaoSaldoIPT ; flows : OperacaoSaldo from fonte to destino } }
